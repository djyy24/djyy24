<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>对江邀月的个人博客</title>
  
  <subtitle>对江邀月24</subtitle>
  <link href="https://djyy24.github.io/djyy24/atom.xml" rel="self"/>
  
  <link href="https://djyy24.github.io/djyy24/"/>
  <updated>2023-11-04T13:21:11.393Z</updated>
  <id>https://djyy24.github.io/djyy24/</id>
  
  <author>
    <name>对江邀月24</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日语学习笔记2</title>
    <link href="https://djyy24.github.io/djyy24/2023/11/04/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>https://djyy24.github.io/djyy24/2023/11/04/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</id>
    <published>2023-11-04T12:38:04.000Z</published>
    <updated>2023-11-04T13:21:11.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔记说明"><a href="#笔记说明" class="headerlink" title="笔记说明"></a>笔记说明</h2><h3 id="此笔记基于哔哩哔哩课程“日语学习：新标日课程0到N1，B站史上最好学的日语入门视频教程零基础学习日语轻松简单学”（BV号BV1Bp4y1D747）"><a href="#此笔记基于哔哩哔哩课程“日语学习：新标日课程0到N1，B站史上最好学的日语入门视频教程零基础学习日语轻松简单学”（BV号BV1Bp4y1D747）" class="headerlink" title="此笔记基于哔哩哔哩课程“日语学习：新标日课程0到N1，B站史上最好学的日语入门视频教程零基础学习日语轻松简单学”（BV号BV1Bp4y1D747）"></a>此笔记基于哔哩哔哩课程“日语学习：新标日课程0到N1，B站史上最好学的日语入门视频教程零基础学习日语轻松简单学”（BV号BV1Bp4y1D747）</h3><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;笔记说明&quot;&gt;&lt;a href=&quot;#笔记说明&quot; class=&quot;headerlink&quot; title=&quot;笔记说明&quot;&gt;&lt;/a&gt;笔记说明&lt;/h2&gt;&lt;h3 id=&quot;此笔记基于哔哩哔哩课程“日语学习：新标日课程0到N1，B站史上最好学的日语入门视频教程零基础学习日语轻松简单学”（</summary>
      
    
    
    
    <category term="外语学习" scheme="https://djyy24.github.io/djyy24/categories/%E5%A4%96%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="日语" scheme="https://djyy24.github.io/djyy24/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语学习笔记</title>
    <link href="https://djyy24.github.io/djyy24/2023/10/26/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://djyy24.github.io/djyy24/2023/10/26/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-26T13:38:04.000Z</published>
    <updated>2023-11-04T13:21:13.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔记说明"><a href="#笔记说明" class="headerlink" title="笔记说明"></a>笔记说明</h2><h3 id="此笔记基于哔哩哔哩课程“日语学习：新标日课程0到N1，B站史上最好学的日语入门视频教程零基础学习日语轻松简单学”（BV号BV1Bp4y1D747）"><a href="#此笔记基于哔哩哔哩课程“日语学习：新标日课程0到N1，B站史上最好学的日语入门视频教程零基础学习日语轻松简单学”（BV号BV1Bp4y1D747）" class="headerlink" title="此笔记基于哔哩哔哩课程“日语学习：新标日课程0到N1，B站史上最好学的日语入门视频教程零基础学习日语轻松简单学”（BV号BV1Bp4y1D747）"></a>此笔记基于哔哩哔哩课程“日语学习：新标日课程0到N1，B站史上最好学的日语入门视频教程零基础学习日语轻松简单学”（BV号BV1Bp4y1D747）</h3><h2 id="Day1-五十音"><a href="#Day1-五十音" class="headerlink" title="Day1 五十音"></a>Day1 五十音</h2><p><strong>あ行是元音，知道あ行以及あ列即可推知其他读音：某行+某列（列的音较长）</strong><br>五十音图表：</p><table>    <tr>        <th>         </th>        <th>            あ段(a)        </th>        <th>            い段(i)        </th>        <th>            う段(u)        </th>        <th>            え段(e)        </th>        <th>            お段(o)        </th>    </tr>    <tr>        <th>            あ行(a)        </th>        <td>あ        </td>        <td>い        </td>        <td>う        </td>        <td>え        </td>        <td>お        </td>    </tr>    <tr>        <th>            か行(k)        </th>        <td>か        </td>        <td>き        </td>        <td>く        </td>        <td>け        </td>        <td>こ        </td>    </tr>    <tr>        <th>            さ行(s)        </th>        <td>さ        </td>        <td>し        </td>        <td>す        </td>        <td>せ        </td>        <td>そ        </td>    </tr>    <tr>        <th>            た行(t)        </th>        <td>た        </td>        <td>ち        </td>        <td>つ        </td>        <td>て        </td>        <td>と        </td>    </tr>    <tr>        <th>            な行(n)        </th>        <td>な        </td>        <td>に        </td>        <td>ぬ        </td>        <td>ね        </td>        <td>の        </td>    </tr>    <tr>        <th>            は行(h)        </th>        <td>は        </td>        <td>ひ        </td>        <td>ふ        </td>        <td>へ        </td>        <td>ほ        </td>    </tr>    <tr>        <th>            ま行(m)        </th>        <td>ま        </td>        <td>み        </td>        <td>む        </td>        <td>め        </td>        <td>も        </td>    </tr>    <tr>        <th>            や行(y)        </th>        <td>や        </td>        <td>        </td>        <td>ゆ        </td>        <td>        </td>        <td>よ        </td>    </tr>    <tr>        <th>            ら行(r)        </th>        <td>ら        </td>        <td>り        </td>        <td>る        </td>        <td>れ        </td>        <td>ろ        </td>    </tr>    <tr>        <th>            わ行(w)        </th>        <td>わ        </td>        <td>        </td>        <td>        </td>        <td>        </td>        <td>を        </td>    </tr>    <tr>        <th>        </th>        <td>ん        </td>        <td>        </td>        <td>        </td>        <td>        </td>        <td>        </td>    </tr></table><p>日文输入测试：<br><textarea style="width:400px;height:50px;"></textarea></p><p>さ行：し读作SHI(类似于师和西之间的音)、す读作SU(类似于苏和思之间的音)<br>た行：つ读作TSU，类似于“茨”、ち读作“CHI”，类似于“七”<br>は行：ふ读作FU，U类似于轻轻吹气<br>や行：ゆ读作YU，发音类似于ü，发音读出去最后收回，よ读作YO，发音类似于“优”<br>ら行：ら行读音为L开头而不是R开头，らLA，りLI，るLU，れLE，ろLO<br>平假名，片假名：相当于用于的小写和大写<br>平假名用于日语本土词语，片假名用于外来词</p><p>日语声调：升调与降调（高音和低音）低音类似于汉语的3声，高音类似于1声</p><h2 id="Day2-日语音调"><a href="#Day2-日语音调" class="headerlink" title="Day2 日语音调"></a>Day2 日语音调</h2><h3 id="一-声调"><a href="#一-声调" class="headerlink" title="一.声调"></a>一.声调</h3><p>低音类似于汉语的3声，高音类似于1声<br>规律：<br>1.第一个音和第二个音高低不同<br>2.出现降音之后不会再升回去，保存在高-&gt;低-&gt;高的情况</p><h4 id="1-声调标记方法"><a href="#1-声调标记方法" class="headerlink" title="1. 声调标记方法"></a>1. 声调标记方法</h4><p>– 方法1：上划线标记：高音的上面划横线</p><p>– 方法2：数字标记</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0型：低高（类比于“我哥”）</span><br><span class="line">1型：高低（类比于“哥哥”）</span><br><span class="line">2型：低高低（类比于“我哥哥”）</span><br><span class="line">3型：低高高低（类比于“美滋滋的”）</span><br><span class="line">n型：第几个音出现“高-&gt;低”的情况，就是几型。第n个音是高音，第n+1个是低音。</span><br><span class="line">没有出现“高-&gt;低”的话就是0型</span><br></pre></td></tr></table></figure><h4 id="2-4型，5型，6型，7型，N型怎么读"><a href="#2-4型，5型，6型，7型，N型怎么读" class="headerlink" title="2. 4型，5型，6型，7型，N型怎么读"></a>2. 4型，5型，6型，7型，N型怎么读</h4><p>参考上文声调标记方法2</p><h4 id="3-0型和2型有什么区别？"><a href="#3-0型和2型有什么区别？" class="headerlink" title="3. 0型和2型有什么区别？"></a>3. 0型和2型有什么区别？</h4><p>两个字的话差别很小，＞＝3个字的话2型是低音收尾，第三位以及之后的助词读音有区别</p><h3 id="二-浊音"><a href="#二-浊音" class="headerlink" title="二.浊音"></a>二.浊音</h3><p>浊音：在字的右上角加上两个小点，か、さ、た、は行<br>半浊音：右上角加一个小圈，仅は行有半浊音<br><strong>か行：发音K-&gt;G</strong><br>が、ぎ、ぐ、げ、ご<br><strong>さ行：发音S-&gt;Z</strong><br>ざ、じ、ず、ぜ、ぞ<br>じ读作“JI”，ず读作“ZI”<br><strong>た行：发音T-&gt;D</strong><br>ぢ读作“JI”，づ读作“ZI”（和じ、ず读音一样，在单词中应注意区分）<br><strong>は行：发音H-&gt;B</strong><br>ば、び、ぶ、べ、ぼ<br><strong>は行半浊音：发音H-&gt;P</strong><br>ぱ、ぴ、ぷ、ぺ、ぽ</p><h3 id="三-长音"><a href="#三-长音" class="headerlink" title="三.长音"></a>三.长音</h3><p>只有两个字在一起的时候才有可能读长音，单独的字都是读短音<br>あ段假名(包括浊音半浊音)+あ<br>い段假名+い</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;笔记说明&quot;&gt;&lt;a href=&quot;#笔记说明&quot; class=&quot;headerlink&quot; title=&quot;笔记说明&quot;&gt;&lt;/a&gt;笔记说明&lt;/h2&gt;&lt;h3 id=&quot;此笔记基于哔哩哔哩课程“日语学习：新标日课程0到N1，B站史上最好学的日语入门视频教程零基础学习日语轻松简单学”（</summary>
      
    
    
    
    <category term="外语学习" scheme="https://djyy24.github.io/djyy24/categories/%E5%A4%96%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="日语" scheme="https://djyy24.github.io/djyy24/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>数据库八股文</title>
    <link href="https://djyy24.github.io/djyy24/2023/10/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    <id>https://djyy24.github.io/djyy24/2023/10/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/</id>
    <published>2023-10-10T14:32:54.000Z</published>
    <updated>2023-10-12T06:35:03.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h1><p>1.字段不可再拆分，保证了原子性<br>2.表中任意一个主键或任意一组联合主键都可以确定所有非主键值<br>3.在第二范式的前提下，不存在某非主键字段A可以获取非主键字段B的情况，消除传递依赖。</p><h1 id="索引的概念"><a href="#索引的概念" class="headerlink" title="索引的概念"></a>索引的概念</h1><p>索引是对数据库表中一个或多个列的值进行排序的结构，有助于快速查找信息（类似于书的目录）<br><strong>索引的优点：</strong>加快查询速度；创建唯一性索引，保证数据库每一行数据的唯一性；加速表和表的连接；在使用分组和排序子句进行检索时，显著减少查询中分组排序的时间。<br><strong>缺点：</strong>占用表之外的物理空间；需要花费时间创建与维护；表进行更新操作时，索引需要被重建。<br><strong>类型：</strong>哈希表，有序数组和搜索树<br>覆盖索引可以减少树的搜索次数，显著提升查询性能，可以使用覆盖索引进行性能优化。</p><h1 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h1><p>1.查询条件中有or，即使有部分条件带索引也会失效<br>2.like查询是以%开头<br>3.如果列类型是字符串，那在查询条件中需要将数据用引号引起来，否则不走索引<br>4.索引列中参与计算会导致索引失效<br>5.违背最左匹配原则<br>6.如果MySQL估计全表扫描要比使用索引要快，会不适用索引</p><h1 id="Redis六种淘汰策略"><a href="#Redis六种淘汰策略" class="headerlink" title="Redis六种淘汰策略"></a>Redis六种淘汰策略</h1><p>1.noeviction(default)：对于写请求不再提供服务，直接返回错误（DEL请求部分特殊请求除外）<br>2.allkeys-LRU：从所有key中使用LRU算法进行淘汰（LRU：最近最少使用算法）<br>3.volatile-LRU：从设置了过期时间的Key中使用LRU算法进行淘汰<br>4.allkeys-random：从所有key中随即淘汰数据<br>5.volatile-random：从设置了过期时间的key中淘汰<br>6.volatile-ttl：在设置了过期时间的key中，淘汰过期时间剩余最短的<br>当使用volatile-lru，volatile-random，volatile这三种策略时，如果没有key可以淘汰，则和noeviction一样返回错误</p><h1 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h1><p>索引用来快速寻找具有特定值得记录，如果没有索引，一般来说会对整张表进行遍历。<br>索引的原理：把无顺序的数据变成有序的查询<br>1.把创建了索引的列的内容进行排序<br>2.对排序的结果生成倒排表<br>3.在倒排表内容上拼上数据地址链<br>4.在查询的时候，先拿到倒排表的内容，再取出数据地址链，从而拿到具体数据</p><h1 id="MySQL聚簇索引"><a href="#MySQL聚簇索引" class="headerlink" title="MySQL聚簇索引"></a>MySQL聚簇索引</h1><p><strong>聚簇索引：</strong>将数据存储和索引放到一起并且按照一定顺序组织，找到索引也就找到了数据，数据的物理处存放顺序和索引数据顺序一致。只要索引是相邻的，那么对应的数据也一定相邻存储在磁盘上。<br><strong>非聚簇索引：</strong>叶子结点不存放数据，存储的是数据行地址，也就是说根据索引查找数据行的位置再去磁盘查找数据，类似于书的目录。<br><strong>聚簇索引的优势：</strong><br>1 直接引用数据，无需二次查询。<br>2 范围查询效率高，因为其数据按照大小排列的。<br>3 聚簇索引更适合排序场合<br><strong>聚簇索引的劣势：</strong><br>1 维护昂贵，特别是插入新行或者主键被更新导致分页的时候。建议在大量插入新行后，选择负载较低的时间段，通过optimize table优化表，使用独享表空间弱化碎片。<br>2 表因为使用UUID作为主键导致数据存储稀疏，这就会出现聚簇索引可能比全盘扫描更慢。因此主键建议使用自增<br>3 如果主键比较大的话，会导致主键值很大，辅助索引也将会变得更大，导致非叶子节点占据更多的物理空间</p><h1 id="Mysql索引的数据结构，优势劣势"><a href="#Mysql索引的数据结构，优势劣势" class="headerlink" title="Mysql索引的数据结构，优势劣势"></a>Mysql索引的数据结构，优势劣势</h1><p>主要有Hash索引，B+树索引等，B+树时InnoDB引擎的默认索引实现。<br><strong>B+树：</strong>一种平衡二叉树，从根节点到每个叶子节点的高度差不超过1，同层级节点之间有指针链接。B+树上进行常规搜索从根节点到叶子节点的搜索效率相当，不会出现大幅波动。在使用基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。<br><strong>哈希索引：</strong>哈希索引就是采用哈希算法把键值换算为哈希值。只需一次哈希算法就可以找到相应位置。在等值查询中占有较大的速度优势。但无法用于范围查询与模糊查询。InnoDB引擎不支持哈希索引。</p><h1 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h1><p>主要原则：查询速度快，占用空间小。<br>1.适合索引的列时出现在Where子句中的列，或者连接子句中指定的列<br>2.基数较小的表不适合建立索引<br>3.使用短索引，如果索引字段较长，应该指定一个前缀长度节省存储空间。搜索词超过前缀则在筛选前缀之后继续向后比较。<br>4.只需保持利于查询的索引，不要过度使用索引，以免占用过多的内存以及更新索引时消耗较多的性能。<br>5.定义有外键的数据一定建立索引。<br>6.更新频繁的字段不适合创建索引，防止索引更新消耗资源。<br>7.不能有效区分数据的列（选项列，值域很小的列）不适合做索引<br>8.尽量扩展已有索引，而不是新建索引。<br>9.对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。<br>10.定义为text，image，bit这三种数据类型的字段不要建立索引</p><h1 id="InnoDB存储引擎的锁的算法"><a href="#InnoDB存储引擎的锁的算法" class="headerlink" title="InnoDB存储引擎的锁的算法"></a>InnoDB存储引擎的锁的算法</h1><p><strong>Record lock：</strong>单个行记录上的锁，行级锁<br><strong>Gap lock：</strong>间隙锁，目的是阻止多个事务将记录插入到同一范围内，但是会发生幻读。两种方式关闭gap锁：将事务隔离级别设置为RC；将参数innodb_locks_unsafe_for_binlog设置为1<br><strong>Next-key lock：</strong>行级锁＋间隙锁，锁定一个范围，包含记录本身，常用于行的查询，解决了Phantom Problem幻读问题</p><h1 id="幻读，脏读，不可重复读"><a href="#幻读，脏读，不可重复读" class="headerlink" title="幻读，脏读，不可重复读"></a>幻读，脏读，不可重复读</h1><p><strong>幻读：</strong>事务A按照一定条件进行数据读取，期间事务B插入了相同条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B新插入的数据，这种情况称为幻读<br><strong>脏读：</strong>某个事务已更新一部分数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个回滚了操作，则后一个事务所读取的数据就会是不正确的。<br><strong>不可重复读：</strong>在一个事务的两次查询中数据不一致，这可能是两次查询过程中间插入了一个十五更新的原有的数据</p><h1 id="事务的基本特性"><a href="#事务的基本特性" class="headerlink" title="事务的基本特性"></a>事务的基本特性</h1><p>-ACID特性：<br><strong>A原子性：</strong>一个事务中的操作要么全成功，要么全部失败。<br><strong>C一致性：</strong>数据库总是从一个一致性的状态转换到另一个一致性的状态<br><strong>I隔离性：</strong>指的是一个事物的修改过程，在最终提交之前，对其他事务都是不可见的。<br><strong>D持久性：</strong>指的是一旦事务提交，所作的修改就会永久保存到数据库中。<br>-ACID特性的保证<br>1.原子性由undo log日志保证，它记录了需要回滚的信息，可以撤销已执行操作<br>2.一致性由原子性，隔离性，持久性共同决定，程序代码要保证业务上的一致性<br>3.隔离性由MVCC保证<br>4.持久性由内存+redo log保证，MySQL修改数据的同时在内存和redo<br>log记录这次操作，宕机的时候可以从redo </p><h1 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h1><p>MVCC：多版本并发控制，读取数据时通过一种类似快照的方式将数据保存下来，这样读锁和写锁就不冲突了。不同的事务session会看到自己特定版本的数据，版本链只在READ COMMITTED和REPEATABLE READ两个隔离级别下工作。其他两个隔离级别和MVCC不兼容，因为READ UNCOMMITTED总是读取到最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行加锁。</p><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><p><strong>1.垂直分表</strong><br>表中的字段比较多，一般将不常用的或者数据较大的字段拆分到扩展表。<br><strong>2.水平分表</strong><br>单表的数据量太大，按照RANGE，Hash取模等规则把一张表切分成多张表，但是这些表仍然在同一库中</p><h1 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h1><p><strong>1.水平分库</strong>单张表的数据库切分后放到多个服务器上去，有效缓解单机和单库的性能瓶颈和压力，突破IO，连接数，硬件资源等瓶颈。<br><strong>2.垂直分库</strong><br>数据库的表太多，把一些表放到其他数据库&#x2F;服务器上。</p><h1 id="分表后非sharding——key的查询怎末处理"><a href="#分表后非sharding——key的查询怎末处理" class="headerlink" title="分表后非sharding——key的查询怎末处理"></a>分表后非sharding——key的查询怎末处理</h1><p>1.做一个映射关系mapping表，保存两表主键之间的关系，查询时先通过一个表查询另一个表，再通过主键去查询。<br>2.宽表，对数据实时性要求不是很高的场景，比如查询订单列表，可以把订单数据同步到离线数仓，基于数仓做张宽表，再基于其他如es提供查询服务。<br>3.数据量不是很大的话，比如后台的一些查询，也可以通过多线程扫表，然后再聚合，或者通过异步的方式。</p><h1 id="分表之后的排序"><a href="#分表之后的排序" class="headerlink" title="分表之后的排序"></a>分表之后的排序</h1><p>排序字段是唯一索引：<br>1.首先进行第一页的查询：合并各表的查询结果，然后再次排序<br>2.第二页之后的查询，需要传入上一页排序的字段最后一个值及排序方式<br>3.根据排序方式以及最后那个值进行查询。如排序字段是date，上一页的最后一个值时3，降序排序，则查询的时候的sql就是select … from table where date &lt;3 order by date desc limit 0,10；这样再把几个表的查询结果进行合并即可。</p><h1 id="MySQL主从同步的过程"><a href="#MySQL主从同步的过程" class="headerlink" title="MySQL主从同步的过程"></a>MySQL主从同步的过程</h1><p>主从复制中主要三个线程：master(logdump thread);slave(I&#x2F;O thread,SQL thread)<br>Master一条线程和slave的两条线程。<br>1.主节点binlog，主从复制的基础是主库记录数据库的所有变更记录到binlog。binlog是数据库服务器启动那一刻起，保存所有数据库变更内容的一个文件。<br>2.主节点logdump线程，当binlog有变动时，logdump线程读取其内容并发送给节点。<br>3.从节点io线程接收binlog内容并写到relay log中。<br>4.从节点的SQL线程读取relay log文件内容对数据更新进行重放，最终保证主从数据库一致。<br>注：主从节点使用binglog文件+position偏移量来定位主从同步的位置，从节点保存position，如果从节点宕机，则会自动从position处发起同步。</p><h1 id="Mysql的全同步复制和半同步复制"><a href="#Mysql的全同步复制和半同步复制" class="headerlink" title="Mysql的全同步复制和半同步复制"></a>Mysql的全同步复制和半同步复制</h1><p>由于MySQL默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后日志就会丢失，因而采取全同步复制或者半同步复制<br><strong>全同步复制</strong><br>主库写入binlog后强制同步日志到从库，所有的从库都执行完后才返回给客户端<br><strong>半同步复制</strong><br>和全同步不同的是，半同步复制的逻辑是从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。</p><h1 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别*"></a>MyISAM和InnoDB的区别*</h1><p><strong>MyISAM</strong><br>不支持事务，但是每次查询都是原子的<br>支持表级锁，每次操作都对整个表加锁<br>存储表的总行数不同<br>一个MyISAM表中包括三个文件：索引文件，表结构文件，数据文件<br>采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。<br><strong>InnoDB</strong><br>支持ACID事务，支持事务的四种隔离级别<br>支持行级锁及外键约束，支持写并发<br>不存储总行数<br>一个InnoDB引擎一般存储在一个文件空间中，也有可能为多个，受操作系统文件大小限制。<br>主键索引采用聚集索引，辅索引的数据域存储主键的值，因此从辅索引查找数据，需要先通过辅索引找到主键的值再访问辅索引。最好使用自增主键，防止插入数据时，为维持B+树的结构，文件大小的调整。</p><h1 id="Mysql中索引的类型"><a href="#Mysql中索引的类型" class="headerlink" title="Mysql中索引的类型"></a>Mysql中索引的类型</h1><p>1.普通索引：允许被索引的数据列包含重复值<br>2.唯一索引：可以保证数据记录的唯一性<br>3.主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字PRIMARY KEY来创建。<br>4.联合索引：索引可以覆盖多个数据列，如像INDEX(columnA,columnB)索引<br>5.全文索引：通过建立倒排索引，极大提升检索效率，解决字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE tablename ADD FULLTEXT(column);创建全文索引。</p><h1 id="索引对数据库性能的影响"><a href="#索引对数据库性能的影响" class="headerlink" title="索引对数据库性能的影响"></a>索引对数据库性能的影响</h1><p>索引可以极大地提高数据查询速度，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统查询性能，但是会降低增删改的性能（涉及到更新索引）<br>索引占据物理空间。聚簇索引占据的空间更大，而且改变时索引更新代价很大。</p><h1 id="Explain分析语句"><a href="#Explain分析语句" class="headerlink" title="Explain分析语句"></a>Explain分析语句</h1><p>通过explain语句的分析，可以了解查询语句的执行情况，找出查询语句执行的瓶颈，从而优化查询语句。<br>explain语句基本语法：<br><strong>explain [EXTENDED] select * from table where name &#x3D; “…”</strong><br>explain查询后的字段：<br>id：select识别符，id越大优先级越高<br>select_type：select关键字对应的查询类型<br>table：表表名<br>partitions匹配的分区信息<br>type：单表查询方式（全表扫描&#x2F;索引）<br>possible_keys：可能用到的索引<br>key：实际上遇到的索引<br>key_len：实际用的索引长度<br>ref：使用索引时，与索引列进行等值匹配的对象信息<br>rows：预估的需要读取的记录条数<br>filtered：某个表经过搜索条件过滤后剩余记录条数的百分比<br>Extra：一些额外的信息，比如排序等</p><h1 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h1><p>索引覆盖是指一个SQL执行时，可以利用索引来快速查找，并且所要查找的字段包含在索引字段中，那么就直接返回索引中的值，不用回表。</p><h1 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h1><p>当一个SQL想要利用索引，就一定要提供该索引所对应的字段中最左边的字段，也就是排在前面的字段。比如针对a，b，c三个字段建立一个联合索引，那麽再写一个SQL时就一定要提供a字段的条件，这样才能用到联合索引。因为索引在创建时是按照先后以a,b,c从左到右来进行排序的，所以如果想要利用B+树快速查找也需要符合这个规则。</p><h1 id="InnoDB如何实现事务"><a href="#InnoDB如何实现事务" class="headerlink" title="InnoDB如何实现事务"></a>InnoDB如何实现事务</h1><p>InnoDB通过Buffer Pool，log Buffer，Redo log实现事务。以一个Update语句为例：<br>1.InnoDB接收到Update，先找到数据所在的页并缓存在BufferPool中<br>2.执行Update，修改BufferPool中的数据，也就是内存中的数据<br>3.针对Update语句生成一个RedoLog对象，并存入LogBuffer中<br>4.针对Update语句生成undoLog，用于回滚<br>5.如果事务提交就把RedoLog持久化，后续还有其他的机制将Buffer Pool中所修改的数据页持久化到磁盘中<br>6.如果事务回滚，则使用undoLog</p><h1 id="MySQL有几种锁？"><a href="#MySQL有几种锁？" class="headerlink" title="MySQL有几种锁？"></a>MySQL有几种锁？</h1><p>按照锁的粒度划分：行级锁，表级锁，页级锁，间隙锁<br>按照锁的共享策略划分：共享锁，排他锁，意向共享锁，意向排他锁<br>加锁策略上划分：乐观锁和悲观锁<br>其他：自增锁</p><h1 id="Redis为什么比较快呢？"><a href="#Redis为什么比较快呢？" class="headerlink" title="Redis为什么比较快呢？"></a>Redis为什么比较快呢？</h1><p>1.Redis是纯内存操作：数据存放在内存，响应速度快<br>2.Redis为非阻塞输入输出，采用epoll作为io多路复用技术的实现，再加上自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在io上浪费过多的时间。<br>3.单线程，避免了线程切换与竞争态产生的消耗。</p><h1 id="SQL优化有哪些方式？"><a href="#SQL优化有哪些方式？" class="headerlink" title="SQL优化有哪些方式？"></a>SQL优化有哪些方式？</h1><p>1.检查是否使用了索引，没有则使用索引<br>2.检查所使用索引是否为最优，优化索引<br>3.检查所查询的字段是否有多余的，去掉sql中多余的字段<br>4.检查表中数据是否过多，是否应该进行分库分表<br>5.检查数据库实例所在的机器的性能配置是否太低并考虑增加资源</p><h1 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h1><p>B树：节点排序，一个节点可以存多个元素，多个元素也会排序<br>B+树：在B树特点的基础上，叶子节点之间有了指针，非叶子节点上的元素在叶子节点上冗余，叶子节点存储了所有元素，并且排好顺序。<br>MySQL索引使用B+树，一个节点存储多个元素使得B+树的高度较低。一个InnODB页就是一个B+树节点，一个InnoDB页默认16KB，所以一般情况下两层的B+树可以存两千万行数据，而且B+树叶子节点已经排序，通过叶子节点之间的指针就可以进行全表扫描与范围查找等。</p><h1 id="truncat和delete的区别"><a href="#truncat和delete的区别" class="headerlink" title="truncat和delete的区别"></a>truncat和delete的区别</h1><p>truncat属于数据定义语言，delete属于数据操作语言。Truncate只能删除表中的数据，无法用在视图上。Delete可以用在表中也可以用在视图。Truncate不能使用where关键字进行选择性删除。Truncate删除缓存不涉及缓存事务处理，delete会涉及到回退，提交，撤退处理。</p><h1 id="左连接，右连接，内连接"><a href="#左连接，右连接，内连接" class="headerlink" title="左连接，右连接，内连接"></a>左连接，右连接，内连接</h1><p>左连接：以左表为基础，根据两张表的条件将两表连接起来结果会将左表所有查询信息列出，右表只显示出ON后条件满足左表的部分。右连接反之。<br>内连接：查询两张表的子集并列出字段，查询结果中只有两个表共有的数据。</p><h1 id="MySQL是怎么解析一条SQL语句的"><a href="#MySQL是怎么解析一条SQL语句的" class="headerlink" title="MySQL是怎么解析一条SQL语句的"></a>MySQL是怎么解析一条SQL语句的</h1><p>查询语句：权限校验-&gt;查询缓存（8.0以前）-&gt;分析器-&gt;优化器-&gt;权限校验-&gt;执行器-&gt;引擎<br>更新语句：分析器-&gt;权限校验-&gt;执行器-&gt;引擎-&gt;redo log prepare-&gt;binlog-&gt;redo log commit</p><hr>参考自：图灵学院周瑜“Java210道面试题”；牛客网各企业面试经]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库的三大范式&quot;&gt;&lt;a href=&quot;#数据库的三大范式&quot; class=&quot;headerlink&quot; title=&quot;数据库的三大范式&quot;&gt;&lt;/a&gt;数据库的三大范式&lt;/h1&gt;&lt;p&gt;1.字段不可再拆分，保证了原子性&lt;br&gt;2.表中任意一个主键或任意一组联合主键都可以确定所有</summary>
      
    
    
    
    <category term="IT技术" scheme="https://djyy24.github.io/djyy24/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="数据库" scheme="https://djyy24.github.io/djyy24/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java面试相关</title>
    <link href="https://djyy24.github.io/djyy24/2023/08/17/Java%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    <id>https://djyy24.github.io/djyy24/2023/08/17/Java%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/</id>
    <published>2023-08-17T06:45:43.000Z</published>
    <updated>2023-08-17T06:45:43.073Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理04-指令系统</title>
    <link href="https://djyy24.github.io/djyy24/2023/08/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%8604-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>https://djyy24.github.io/djyy24/2023/08/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%8604-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-08-06T02:27:25.000Z</published>
    <updated>2023-08-08T02:31:25.183Z</updated>
    
    <content type="html"><![CDATA[<p><strong>指令</strong>：指示计算机执行某种操作的命令，是计算机运行的最小单位。一台计算机的所有指令的集合构成该计算机的<strong>指令系统</strong>。也成为<strong>指令集</strong>。<br>eg:X86架构，ARM架构</p><h1 id="4-1-指令格式"><a href="#4-1-指令格式" class="headerlink" title="4.1 指令格式"></a>4.1 指令格式</h1><p>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码<br>一条指令分为<strong>操作码</strong>和<strong>地址码</strong>两部分：</p><ul><li><strong>操作码（OP）</strong>：用户要干什么，做什么运算或者事情</li><li><strong>地址码（A）</strong>：要对谁进行操作，没有操作对象或者一个或者多个操作对象<br>一条指令为一个操作码和0~多个地址码。</li></ul><h2 id="按照地址码数量分类："><a href="#按照地址码数量分类：" class="headerlink" title="按照地址码数量分类："></a><strong>按照地址码数量分类：</strong></h2><p><strong>1.零地址指令</strong><br>格式：</p><blockquote><p><strong>OP</strong></p></blockquote><ul><li>无需操作数，例如空操作，停机，关中断等</li><li>堆栈计算机，两个操作数<strong>隐含在</strong>栈顶和次栈顶，把计算结果压入栈顶。（数据结构：后缀表达式）</li></ul><p><strong>2.一地址指令</strong><br>格式：</p><blockquote><p><strong>OP A1</strong></p></blockquote><p>（A1表示操作数的<strong>地址</strong>）<br>指令含义：OP(A1)-&gt;A1    </p><ul><li>只需要一个操作数的运算（取反，加1等运算）完成三次访存：取出指令-&gt;读取A1处的值-&gt;运算后把结果写在A1处</li><li>需要两个操作数，但是其中一个操作数隐含在某个寄存器（如ACC）中。完成2次访存：取出指令-&gt;读取A1并把运算结果存入ACC累加寄存器中。</li></ul><p><strong>3.二地址指令</strong><br>格式：</p><blockquote><p><strong>OP A1 A2</strong></p></blockquote><p>指令含义：(A1)OP(A2)-&gt;A1<br>用于两个数的算术运算及逻辑运算<br>四次访存：取出指令，读取A1，读取A2，结果写入A1</p><p><strong>4.三地址指令</strong><br>格式：</p><blockquote><p><strong>OP A1 A2 A3</strong></p></blockquote><p>指令含义：(A1)OP(A2)-&gt;A3<br>用于两个数的算术运算及逻辑运算<br>四次访存：取出指令，读取A1，读取A2，结果写入A3</p><p><strong>5.四地址指令</strong><br>格式：</p><blockquote><p><strong>OP A1 A2 A3 NEXT</strong><br>指令含义：(A1)OP(A2)-&gt;A3;NEXT&#x3D;下一条将要执行指令的地址<br>用于两个数的算术运算及逻辑运算<br>四次访存：取出指令，读取A1，读取A2，结果写入A3<br><strong>执行完指令后，将PC的值修改为NEXT的值</strong>，而不是把PC的值+1，便于跳着执行指令</p></blockquote><p><strong>若指令长度不变，则地址码数量越多，单个地址码寻址范围越小，寻址能力越差。</strong></p><h2 id="按照指令长度分类（看指令总长度）"><a href="#按照指令长度分类（看指令总长度）" class="headerlink" title="按照指令长度分类（看指令总长度）"></a><strong>按照指令长度分类</strong>（看指令总长度）</h2><ul><li>指令字长：一条指令的总长度</li><li>机器字长：CPU单次可处理二进制位数</li><li>存储字长：一个存储单元中的二进制代码位数（和MDR位数相同）<br>半字长指令，单字长指令，双字长指令中的字长为机器字长<br><strong>1.定长指令字结构</strong>：指令系统中所有指令长度相等<br><strong>2.定长指令字结构</strong>：指令系统中各种指令的长度不相等</li></ul><h2 id="按操作码长度分类（看指令中操作码的长度）"><a href="#按操作码长度分类（看指令中操作码的长度）" class="headerlink" title="按操作码长度分类（看指令中操作码的长度）"></a><strong>按操作码长度分类</strong>（看指令中操作码的长度）</h2><p><strong>1.定长操作码</strong>：指令系统中所有指令的操作码长度都相同<br><strong>2.可变长操作码</strong>：指令系统各个指令中的操作码长度可变</p><h2 id="按操作类型分类"><a href="#按操作类型分类" class="headerlink" title="按操作类型分类"></a><strong>按操作类型分类</strong></h2><p>1.数据传送<br>2.算术逻辑操作<br>3.移位操作<br>4.转移操作（改变PC的值）</p><h2 id="扩展操作码指令格式"><a href="#扩展操作码指令格式" class="headerlink" title="扩展操作码指令格式"></a><strong>扩展操作码指令格式</strong></h2><p><strong>扩展操作码</strong><br>例：指令字长为16位，4个地址码，每个地址码占4位。</p><ul><li><strong>三地址指令</strong>：4位操作码全部用于三地址指令：把第一个操作码中的1111保留，一共有15位三地址指令。<blockquote><p>OP A1 A2 A3</p></blockquote></li><li><strong>二地址指令</strong>：第1个地址码设置为1111表示这个是二地址指令，保留第二位地址码的1111（留作扩展操作码），一共15条<blockquote><p>1111 OP A1 A2</p></blockquote></li><li><strong>一地址指令</strong>：第1，2个地址码设置为1111表示这个是一地址指令，保留第三位地址码的1111，一共15条<blockquote><p>1111 1111 OP A1</p></blockquote></li><li><strong>零地址指令</strong>：前三个地址码都设置为1111，一共16条<blockquote><p>1111 1111 1111 OP</p></blockquote></li></ul><p>设计扩展操作码指令格式时，应该注意：<strong>以下两点</strong></p><ul><li>不允许短吗是长码的前缀，短操作码不能与长操作码的前边部分相同（所以要保留1111）</li><li>各指令的操作码一定不能重复<br>给使用频率较高的指令编更短的操作码，较少指令译码和分析的时间。<br>设地址长度为n，上一层留出m种状态，下一层可扩展出m×2^n种状态。<br><a href="1.png">例题图片1</a></li></ul><h1 id="4-2-指令寻址"><a href="#4-2-指令寻址" class="headerlink" title="4.2 指令寻址"></a>4.2 指令寻址</h1><p>指令寻址：如何确定下一条指令的存放地址，分为<strong>顺序寻址和跳跃寻址</strong></p><ul><li>顺序寻址：由PC（程序计数器）确定将要执行哪个指令，执行难完成后PC自增<br>自增的数根据取址方式（按字取址&#x2F;按字节取址）以及指令长度确定。</li><li>跳跃寻址：JMP指令（无条件转移），设置PC的值，跳转到某个指令地址；call（调用）指令；这些指令会改变程序的执行流（直接修改PC的值，不顺序执行）<br><em>每次CPU寻找到一个指令后PC立马增加</em></li></ul><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><p>数据寻址：确定本条指令的地址码指明的真实地址</p><h2 id="10种数据寻址方式："><a href="#10种数据寻址方式：" class="headerlink" title="10种数据寻址方式："></a>10种数据寻址方式：</h2><p>使用四个比特位用于标记寻址方式（寻址特征）<br>操作数的真实地址（有效地址）包括了寻址特征和形式地址<br>假设指令字长&#x3D;机器字长&#x3D;存储字长</p><ul><li><p>1.直接寻址<br>指令字中的形式地址为操作数在内存中的真实地址<br>访存2次：读取指令，执行指令<br><strong>优点</strong> 原理简单，无需专门计算操作数地址，执行期间仅需访存一次<br><strong>缺点</strong> 寻址范围受形式地址位数制约，操作数地址不易修改，灵活性差</p></li><li><p>2.间接寻址<br>指令字中地址指向的存储单元中存放操作数的地址，根据这个地址再去读取操作数。<br><strong>优点</strong> 可扩大寻址范围（存储单元中可以存储更长的有效地址码）；多层间接寻址便于编制程序。<br><strong>缺点</strong> 需要进行两次及以上的访存，效率较低。</p></li><li><p>3.寄存器寻址<br>指令中的有效地址指向操作数所在的寄存器编号。在取指令的时候进行一次访存。<br><strong>优点</strong> 指令执行阶段无需访存，只需访问寄存器，指令字短而且执行速度快，支持向量&#x2F;矩阵运算<br><strong>缺点</strong> 寄存器成本高，数量有限</p></li><li><p>4.寄存器间接寻址<br>指令中地址指向寄存器，寄存器中存放操作数在内存中的地址<br>两次访存：取指令，读取操作数<br><strong>优点</strong>* 较间接寻址速度较快</p></li><li><p>5.隐含寻址<br>不是明显的给出操作数地址，而是在指令中隐含着操作数的地址（可能操作数隐含在ACC累加寄存器中）<br><strong>优点</strong> 有利于缩短指令字长<br><strong>缺点</strong>需增加存储操作数或隐含地址的硬件</p></li><li><p>6.立即寻址<br>形式地址A中直接存放操作数本身，又称立即数，一般采用补码的形式。<br>格式： 操作码OP # 操作数二进制值<br><em>#表示立即寻址的特征码</em><br><strong>优点</strong> 执行期间无需访存，指令执行时间最短<br><strong>缺点</strong> A的位数限制了立即数的范围</p></li><li><p>7.基址寻址<br>将CPU中基址寄存器BR的内容加上指令格式真的形式地址A，而形成操作数的有效地址EA，即EA&#x3D;(BR)+A    EA&#x3D;基址+偏移量<br>BR：基址寄存器，重定位寄存器<br>-采用专用寻址寄存器：OP 寻址特征 A<br>-若采用通用寄存器则需要指明哪个寄存器作为基址寄存器：OP 寻址特征 <em>R0</em> A<br>优点：便于程序的“浮动”，方便实现多道程序并发运行。 </p></li><li><p>8.变址寻址<br>有效地址EA等于指令中的形式地址A加上变址寄存器IX中的地址：EA&#x3D;A+IX。<br>IX：可为变址寄存器（专用），也可以是通用寄存器。<br><strong>注：</strong>变址寄存器为面向用户的寄存器。和基址寻址不同，在程序执行的过程中，变址寄存器的内容IX可以由用户改变（程序执行时可更改IX中的值）。<br>在数组处理的过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任意一组数据的地址，特别适合<em>编制循环程序</em>。</p></li><li><p>9.基址&amp;变址复合寻址</p></li><li><p>10.相对寻址<br>把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址：<br>EA&#x3D;PC+A，A小于零表示执行PC之前的指令；<em>在计算有效地址之前PC会自增，因为在读取一条指令之后PC会立即自增，也就是说相对寻址是相对于下一条指令的偏移</em><br>优点：这段代码在程序内浮动时不用更改跳转指令的地址码（代码换位置之后不用把里面的条件跳转指令的地址码也重新设置）</p></li></ul><p><strong>硬件如何实现数的比较？</strong><br>if(a&gt;b){}<br>else{}语句：<br>硬件视角：<br>1.通过cmp指令比较a和b<br>2.相-的结果信息记录在程序状态字寄存器PSW中。PSW中有几个比特位记录上次运算的结果（包含了进位借位，零标志，符号标志，溢出标记）。<br>3.根据PSW中的标记决定是否转移<br>PSW：程序状态字寄存器&#x2F;标志寄存器</p><p><strong>堆栈寻址</strong><br>操作数存放在堆栈中，隐含使用堆栈指针SP作为操作数地址。在栈顶取值，SP+1，计算后把计算结果存入栈顶，SP-1。</p><ul><li>硬堆栈：堆栈是一个寄存器组，无需访问内存，速度快，成本高</li><li>软堆栈：堆栈位于主存中，需要访问主存，速度慢，成本低<br>堆栈可用于函数调用时保存当前函数的相关信息<br><a href="2.png">堆栈寻址</a></li></ul><h1 id="4-3-高级语言与机器代码之间的对应"><a href="#4-3-高级语言与机器代码之间的对应" class="headerlink" title="4.3 高级语言与机器代码之间的对应"></a>4.3 高级语言与机器代码之间的对应</h1><p>需要掌握X86格式的汇编语言，结合C语言看懂汇编语言的关键语句（常见指令，选择结构，循环结构，函数调用），结合汇编语言分析机器语言指令的格式，寻址方式。</p><h2 id="以mov指令为例："><a href="#以mov指令为例：" class="headerlink" title="以mov指令为例："></a>以mov指令为例：</h2><p><strong>mov指令格式：  mov 目的操作数d,源操作数s</strong></p><blockquote><p>mov eax,ebx#把寄存器ebx中的值复制到寄存器eax中<br>mov eax,5 #把立即数5复制到寄存器eax中<br>mov eax,dword ptr [af996h] #把地址“af996h”处的值(取值长度为2个字)复制到寄存器eax中<br>mox byte ptr [af996h],ebx #把寄存器ebx中的值复制到地址“af996h”处(取值长度为1个字节)</p></blockquote><p>[…]地址指明内存的读写长度：</p><ul><li>dword ptr：双字，32bit</li><li>word ptr：单字，16bit</li><li>byte ptr：字节，8bit</li></ul><p><strong>X86架构CPU中的所有寄存器：</strong><br>EAX：通用寄存器E&#x3D;Extended&#x3D;一个寄存器32bit；通用寄存器可以存放任意内容<br>EBX：通用寄存器<br>ECX：通用寄存器<br>EDX：通用寄存器<br>ESI：变址寄存器（源地址索引）<br>EDI：变址寄存器（目的地址索引）<br>EBP：堆栈基指针<br>ESP：堆栈顶指针</p><p>（基于王道考研-计算机组成原理） </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;指令&lt;/strong&gt;：指示计算机执行某种操作的命令，是计算机运行的最小单位。一台计算机的所有指令的集合构成该计算机的&lt;strong&gt;指令系统&lt;/strong&gt;。也成为&lt;strong&gt;指令集&lt;/strong&gt;。&lt;br&gt;eg:X86架构，ARM架构&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://djyy24.github.io/djyy24/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机组成原理" scheme="https://djyy24.github.io/djyy24/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【刘宇二创】还原《AYO》舞蹈背景中的白色小楼</title>
    <link href="https://djyy24.github.io/djyy24/2023/08/03/%E3%80%90%E5%88%98%E5%AE%87%E4%BA%8C%E5%88%9B%E3%80%91%E8%BF%98%E5%8E%9F%E3%80%8AAYO%E3%80%8B%E8%88%9E%E8%B9%88%E8%83%8C%E6%99%AF%E4%B8%AD%E7%9A%84%E7%99%BD%E8%89%B2%E5%B0%8F%E6%A5%BC/"/>
    <id>https://djyy24.github.io/djyy24/2023/08/03/%E3%80%90%E5%88%98%E5%AE%87%E4%BA%8C%E5%88%9B%E3%80%91%E8%BF%98%E5%8E%9F%E3%80%8AAYO%E3%80%8B%E8%88%9E%E8%B9%88%E8%83%8C%E6%99%AF%E4%B8%AD%E7%9A%84%E7%99%BD%E8%89%B2%E5%B0%8F%E6%A5%BC/</id>
    <published>2023-08-03T12:08:37.000Z</published>
    <updated>2023-08-03T13:13:18.297Z</updated>
    
    <content type="html"><![CDATA[<p>还原刘宇新歌《AYO》舞蹈版视频背景中的白色小楼<br><img src="https://img1.imgtp.com/2023/08/03/Qls6Exny.jpg"><br>使用多层硬纸板制作的15cm*6.5cm微缩版桌面摆件，内置3个并联的发光二极管作为光源，达到夜晚开灯效果。两节7号电池作为电源，背面的电池仓盖带有磁吸。<br><img src="https://img1.imgtp.com/2023/08/03/t9HERlQz.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;还原刘宇新歌《AYO》舞蹈版视频背景中的白色小楼&lt;br&gt;&lt;img src=&quot;https://img1.imgtp.com/2023/08/03/Qls6Exny.jpg&quot;&gt;&lt;br&gt;使用多层硬纸板制作的15cm*6.5cm微缩版桌面摆件，内置3个并联的发光二极管作为光源，达到</summary>
      
    
    
    
    <category term="手工制作" scheme="https://djyy24.github.io/djyy24/categories/%E6%89%8B%E5%B7%A5%E5%88%B6%E4%BD%9C/"/>
    
    
    <category term="手作" scheme="https://djyy24.github.io/djyy24/tags/%E6%89%8B%E4%BD%9C/"/>
    
    <category term="建筑" scheme="https://djyy24.github.io/djyy24/tags/%E5%BB%BA%E7%AD%91/"/>
    
    <category term="纸艺" scheme="https://djyy24.github.io/djyy24/tags/%E7%BA%B8%E8%89%BA/"/>
    
    <category term="粉丝二创" scheme="https://djyy24.github.io/djyy24/tags/%E7%B2%89%E4%B8%9D%E4%BA%8C%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>【刘宇二创】手工自制《文刀刘》专辑歌词影像集</title>
    <link href="https://djyy24.github.io/djyy24/2023/08/03/%E3%80%90%E5%88%98%E5%AE%87%E4%BA%8C%E5%88%9B%E3%80%91%E6%89%8B%E5%B7%A5%E8%87%AA%E5%88%B6%E3%80%8A%E6%96%87%E5%88%80%E5%88%98%E3%80%8B%E4%B8%93%E8%BE%91%E6%AD%8C%E8%AF%8D%E5%BD%B1%E5%83%8F%E9%9B%86/"/>
    <id>https://djyy24.github.io/djyy24/2023/08/03/%E3%80%90%E5%88%98%E5%AE%87%E4%BA%8C%E5%88%9B%E3%80%91%E6%89%8B%E5%B7%A5%E8%87%AA%E5%88%B6%E3%80%8A%E6%96%87%E5%88%80%E5%88%98%E3%80%8B%E4%B8%93%E8%BE%91%E6%AD%8C%E8%AF%8D%E5%BD%B1%E5%83%8F%E9%9B%86/</id>
    <published>2023-08-03T11:59:46.000Z</published>
    <updated>2023-08-03T13:12:50.467Z</updated>
    
    <content type="html"><![CDATA[<p>龙鳞装是中国古代图书的一种装帧形式之一 ， 亦称“旋风叶”、“旋风装”。唐代中叶已有此种形式 。<br><img src="https://img1.imgtp.com/2023/08/03/xA7qWYzd.jpg"><br>2022年11月9日，看了河南卫视的《如麟一梦》，自己手写了一个简配的仿龙鳞装，后来想到可以在歌词旁边加上图片，每个图片与歌词相对应，于是以此为灵感，制作了一个《文刀刘》专辑歌词影像集。<br><img src="https://img1.imgtp.com/2023/08/03/GNQyBh9y.jpg"></p><p>（2023年1月9日制作）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;龙鳞装是中国古代图书的一种装帧形式之一 ， 亦称“旋风叶”、“旋风装”。唐代中叶已有此种形式 。&lt;br&gt;&lt;img src=&quot;https://img1.imgtp.com/2023/08/03/xA7qWYzd.jpg&quot;&gt;&lt;br&gt;2022年11月9日，看了河南卫视的《如麟一梦</summary>
      
    
    
    
    <category term="手工制作" scheme="https://djyy24.github.io/djyy24/categories/%E6%89%8B%E5%B7%A5%E5%88%B6%E4%BD%9C/"/>
    
    
    <category term="手作" scheme="https://djyy24.github.io/djyy24/tags/%E6%89%8B%E4%BD%9C/"/>
    
    <category term="纸艺" scheme="https://djyy24.github.io/djyy24/tags/%E7%BA%B8%E8%89%BA/"/>
    
    <category term="粉丝二创" scheme="https://djyy24.github.io/djyy24/tags/%E7%B2%89%E4%B8%9D%E4%BA%8C%E5%88%9B/"/>
    
    <category term="非遗" scheme="https://djyy24.github.io/djyy24/tags/%E9%9D%9E%E9%81%97/"/>
    
  </entry>
  
  <entry>
    <title>在线小工具页</title>
    <link href="https://djyy24.github.io/djyy24/2023/08/03/%E5%9C%A8%E7%BA%BF%E5%B0%8F%E5%B7%A5%E5%85%B7%E9%A1%B5/"/>
    <id>https://djyy24.github.io/djyy24/2023/08/03/%E5%9C%A8%E7%BA%BF%E5%B0%8F%E5%B7%A5%E5%85%B7%E9%A1%B5/</id>
    <published>2023-08-03T10:42:30.000Z</published>
    <updated>2023-09-08T13:40:48.513Z</updated>
    
    <content type="html"><![CDATA[<p>因为Markdown格式可以和HTML，JavaScript混编，所以就做了一个博客页专门放各种网页端小工具<br>计算器：</p><div style="width:200px;height:212px;background:#8dbcf4">    <input id="screen" style="height:24.5px;margin:15px;margin-right: 0px;width:140px">    <button style="border: solid 1px;background: #ffffff;width:21px;height:24px;padding: 3px;margin: 0px;" onclick="document.getElementById('screen').value=document.getElementById('screen').value=''">C</button>    <button style="background: #ffffff;width:24px;height:24px;padding: 3px;margin: 6px;margin-left: 25px;" onclick="document.getElementById('screen').value=document.getElementById('screen').value+'7'">7</button>    <button style="background: #ffffff;width:24px;height:24px;padding: 3px;margin: 6px;" onclick="document.getElementById('screen').value=document.getElementById('screen').value+'8'">8</button>    <button style="background: #ffffff;width:24px;height:24px;padding: 3px;margin: 6px;" onclick="document.getElementById('screen').value=document.getElementById('screen').value+'9'">9</button>    <button style="background: #3fffff;width:24px;height:24px;padding: 3px;margin: 6px;" onclick="mod=1;a=Number(document.getElementById('screen').value);document.getElementById('screen').value=''">+</button><br>    <button style="background: #ffffff;width:24px;height:24px;padding: 3px;margin: 6px;margin-left: 25px;" onclick="document.getElementById('screen').value=document.getElementById('screen').value+'4'">4</button>    <button style="background: #ffffff;width:24px;height:24px;padding: 3px;margin: 6px;" onclick="document.getElementById('screen').value=document.getElementById('screen').value+'5'">5</button>    <button style="background: #ffffff;width:24px;height:24px;padding: 3px;margin: 6px;" onclick="document.getElementById('screen').value=document.getElementById('screen').value+'6'">6</button>    <button style="background: #3fffff;width:24px;height:24px;padding: 3px;margin: 6px;" onclick="mod=2;a=Number(document.getElementById('screen').value);document.getElementById('screen').value=''">-</button><br>    <button style="background: #ffffff;width:24px;height:24px;padding: 3px;margin: 6px;margin-left: 25px;" onclick="document.getElementById('screen').value=document.getElementById('screen').value+'1'">1</button>    <button style="background: #ffffff;width:24px;height:24px;padding: 3px;margin: 6px;" onclick="document.getElementById('screen').value=document.getElementById('screen').value+'2'">2</button>    <button style="background: #ffffff;width:24px;height:24px;padding: 3px;margin: 6px;" onclick="document.getElementById('screen').value=document.getElementById('screen').value+'3'">3</button>    <button style="background: #3fffff;width:24px;height:24px;padding: 3px;margin: 6px;" onclick="mod=3;a=Number(document.getElementById('screen').value);document.getElementById('screen').value='';">x</button><br>    <button style="background: #ff0000;width:24px;height:24px;padding: 3px;margin: 6px;margin-left: 25px;" onclick="calculate()">=</button>    <button style="background: #ffffff;width:24px;height:24px;padding: 3px;margin: 6px;" onclick="document.getElementById('screen').value=document.getElementById('screen').value+'0'">0</button>    <button style="background: #ffffff;width:24px;height:24px;padding: 3px;margin: 6px;" onclick="document.getElementById('screen').value=document.getElementById('screen').value+'.'">.</button>    <button style="background: #3fffff;width:24px;height:24px;padding: 3px;margin: 6px;" onclick="mod=4;a=Number(document.getElementById('screen').value);document.getElementById('screen').value='';console.log(a)">/</button>    <script>        var mod=0;        var a;        function calculate()        {            let b;            b=Number(document.getElementById("screen").value);            console.log(a,b);            if(mod==1)            {                document.getElementById("screen").value=a+b;            }            if(mod==2)            {                document.getElementById("screen").value=a-b;            }            if(mod==3)            {                document.getElementById("screen").value=a*b;            }            if(mod==4)            {                document.getElementById("screen").value=a/b;            }        }        function func(){    var days=[0,31,29,31,30,31,30,31,31,30,31,30,31]    var m=document.getElementById("yue").value;    var d=document.getElementById("ri").value;    if(m>12||m<1||d>days[m]||d<1)        {document.getElementById("jieguo").value="日期数值超出范围";    return;}    var y=1910;    if(d==13&&m==12)    {document.getElementById("jieguo").value="--";    return;}    if(m==12&&d>13)        {            d=d-1;        }if(d==31)        y=y+10+(m-1)*10;    else        y=y+(m-1)*10+parseInt((d-1)/3)+1;    console.log(y);    if(y>2020)        y=y-120;    document.getElementById("jieguo").value=y;}function func2(){    var y=document.getElementById("y").value;    if(y<1901||y>2021)        {document.getElementById("jieguo2").value="年数超出范围（1901--2020）";    return;}    if(y>1900&&y<1911)        {            let str="12月";            let dd=(y-1900)*3-2;            if(dd>=13)                dd++;            str=str+dd+"日（第一天）";            document.getElementById("jieguo2").value=str;            return;        }    var y2=y-1910-1;    var m=1+parseInt(y2/10)    var d=y2%10*3+1    var str=m+"月"+d+"日（第一天）";    document.getElementById("jieguo2").value=str;}    </script></div><hr><div style="width: 600px;height: 320px;border: solid 2px;"><strong>月日转年：</strong><br>    请输入月：<input id="yue">    请输入日：<input id="ri"> <span onclick="func()" style="color: blue;"> 确 认 </span>    <br><br>计算结果： <input id="jieguo"><hr><strong>年转月日：</strong><br>    <body>    请输入年：<input id="y"> <span onclick="func2() " style="color: blue;"> 确 认 </span>    <br><br>计算结果： <input id="jieguo2"></body></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为Markdown格式可以和HTML，JavaScript混编，所以就做了一个博客页专门放各种网页端小工具&lt;br&gt;计算器：&lt;/p&gt;
&lt;div style=&quot;width:200px;height:212px;background:#8dbcf4&quot;&gt;
    &lt;input i</summary>
      
    
    
    
    <category term="IT技术" scheme="https://djyy24.github.io/djyy24/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="https://djyy24.github.io/djyy24/tags/JavaScript/"/>
    
    <category term="HTML" scheme="https://djyy24.github.io/djyy24/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Simp网址导航-共享式新型导航</title>
    <link href="https://djyy24.github.io/djyy24/2023/08/03/Simp%E7%BD%91%E5%9D%80%E5%AF%BC%E8%88%AA-%E5%85%B1%E4%BA%AB%E5%BC%8F%E6%96%B0%E5%9E%8B%E5%AF%BC%E8%88%AA/"/>
    <id>https://djyy24.github.io/djyy24/2023/08/03/Simp%E7%BD%91%E5%9D%80%E5%AF%BC%E8%88%AA-%E5%85%B1%E4%BA%AB%E5%BC%8F%E6%96%B0%E5%9E%8B%E5%AF%BC%E8%88%AA/</id>
    <published>2023-08-03T02:41:41.000Z</published>
    <updated>2023-08-03T03:10:51.376Z</updated>
    
    <content type="html"><![CDATA[<p>基于Vue3的简洁版网址导航，服务端使用SpringBoot2.7.13。<br><a href="http://djyy24.top/daohang" target="_blank">Simp网址导航</a><br>致力于制作出一个共享型的网址导航，用户可以把自己喜欢的网站添加进来，和众多用户一同分享一些宝藏网站。网址分享无需登录，点击右上角“添加新网站”后提交表单，审核通过之后就会加入到网址导航中。该网址导航可以作为浏览器首页。<br><img src="https://djyy24.top/images/software/0.png"><br>制作Simp网址导航最开始是想做一个比较简洁，集合了大量宝藏网站的页面，像一个工具箱，实现一站式的网页查找，方便快捷地满足用户需求。后来在制作过程中感觉每次新加入网站都要在更改页面后重新部署，比较麻烦，不如直接把网址导航中的链接直接放进数据库，导航加载时读取数据库中的链接并且渲染到页面。想要添加网址时直接添加到数据库中，无需重新部署。<br>带着这个想法，制作了这个SpringBoot+MySQL作为后端的网址导航。通过向服务端发送请求的方式管理导航链接，实现更方便快捷的维护。<br>这种维护方式可以开放给用户，让用户把自己喜欢的网站分享到网址导航中，和大家共享。</p><p>网址分享无需登录，点击右上角“添加新网站”后提交表单，审核通过之后就会加入到网址导航中。该网址导航可以作为浏览器首页。<br><img src="https://img1.imgtp.com/2023/08/03/tAnMK8Ih.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于Vue3的简洁版网址导航，服务端使用SpringBoot2.7.13。&lt;br&gt;&lt;a href=&quot;http://djyy24.top/daohang&quot; target=&quot;_blank&quot;&gt;Simp网址导航&lt;/a&gt;&lt;br&gt;致力于制作出一个共享型的网址导航，用户可以把自己喜欢的网</summary>
      
    
    
    
    <category term="IT技术" scheme="https://djyy24.github.io/djyy24/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://djyy24.github.io/djyy24/tags/Java/"/>
    
    <category term="Spring" scheme="https://djyy24.github.io/djyy24/tags/Spring/"/>
    
    <category term="MySQL" scheme="https://djyy24.github.io/djyy24/tags/MySQL/"/>
    
    <category term="Vue" scheme="https://djyy24.github.io/djyy24/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>基于SpringBoot+Vue的图书馆信息化系统</title>
    <link href="https://djyy24.github.io/djyy24/2023/08/03/%E5%9F%BA%E4%BA%8ESpringBoot-Vue%E7%9A%84%E5%9B%BE%E4%B9%A6%E9%A6%86%E4%BF%A1%E6%81%AF%E5%8C%96%E7%B3%BB%E7%BB%9F/"/>
    <id>https://djyy24.github.io/djyy24/2023/08/03/%E5%9F%BA%E4%BA%8ESpringBoot-Vue%E7%9A%84%E5%9B%BE%E4%B9%A6%E9%A6%86%E4%BF%A1%E6%81%AF%E5%8C%96%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-08-03T01:51:37.000Z</published>
    <updated>2023-08-03T11:48:30.451Z</updated>
    
    <content type="html"><![CDATA[<p>基于SpringBoot框架开发的B-S架构图书馆信息化系统，支持图书馆账户注册与管理，书籍借还等业务逻辑，支持后台管理。<br>2023年七月初学习了SpringBoot后端开发，当时做了一个小型备忘录程序作为练习，业务逻辑比较简单而且只有两张表。<br>7月15日开始制作一个更复杂的图书馆系统，历时九天制作完成第一版。<br><a href="http://8.141.83.100:100">图书馆信息化系统</a><br><img src="https://img1.imgtp.com/2023/08/03/z9zQqUfG.jpg"><br>图书馆系统数据存储使用MySQL数据库，包含了用户表，管理员表，借阅记录表，书籍信息表。通过MyBatis plus进行数据库的相关操作，包括映射，增删改查以及自定义MySQL语句等。<br>利用SpringBoot2.7.13框架编写的服务端程序，用于后台处理请求以及相关数据，打包好的后端服务程序jar包放置在服务器上运行。<br>利用Vue制作前端界面，包括GUI和JavaScript，GUI基于Element-ui编写，JavaScript部分主要用于向后端发送请求以及一小部分数据处理。<br><img src="https://img1.imgtp.com/2023/08/03/zZJlFiKC.jpg"><br>主要功能：<br>•图书馆用户注册与账户登录，信息修改等功能。<br>•用户借阅图书以及归还书籍功能，查询借阅记录。<br>•管理员功能：管理用户，书籍，借阅记录等数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于SpringBoot框架开发的B-S架构图书馆信息化系统，支持图书馆账户注册与管理，书籍借还等业务逻辑，支持后台管理。&lt;br&gt;2023年七月初学习了SpringBoot后端开发，当时做了一个小型备忘录程序作为练习，业务逻辑比较简单而且只有两张表。&lt;br&gt;7月15日开始制</summary>
      
    
    
    
    <category term="IT技术" scheme="https://djyy24.github.io/djyy24/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://djyy24.github.io/djyy24/tags/Java/"/>
    
    <category term="Spring" scheme="https://djyy24.github.io/djyy24/tags/Spring/"/>
    
    <category term="MySQL" scheme="https://djyy24.github.io/djyy24/tags/MySQL/"/>
    
    <category term="Vue" scheme="https://djyy24.github.io/djyy24/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>建筑楼层批量复制Mod</title>
    <link href="https://djyy24.github.io/djyy24/2023/08/02/%E5%BB%BA%E7%AD%91%E6%A5%BC%E5%B1%82%E6%89%B9%E9%87%8F%E5%A4%8D%E5%88%B6Mod/"/>
    <id>https://djyy24.github.io/djyy24/2023/08/02/%E5%BB%BA%E7%AD%91%E6%A5%BC%E5%B1%82%E6%89%B9%E9%87%8F%E5%A4%8D%E5%88%B6Mod/</id>
    <published>2023-08-02T14:10:06.000Z</published>
    <updated>2023-08-02T15:24:34.737Z</updated>
    
    <content type="html"><![CDATA[<p>建筑楼层批量复制模组（Bulk copy of building floor），为创造模式制作的建筑辅助模组，确定单层楼层的端点坐标后一次性向上复制多层楼层，可以避免楼层复制指令的重复使用。<br>模组运行原理为按照规律自动生成并执行多条 &#x2F;clone 指令。</p><p>加入了区域复制功能，用目标坐标查看器保存区域两端坐标以及目的地坐标就可以一键复制。原理也是自动输入&#x2F;clone指令，但是无需使用记事本记坐标。<br>戏版本：Java版 1.16.5<br>制作完成时间：2023年2月末<br><img src="https://img1.imgtp.com/2023/08/02/aLIi8Hoj.png"></p><p>本模组使用Gradle Java与forge开发，开发环境为Intellij IDEA Community Edition 2022和JDK18，适用于Minecraft Java Edition 1.16.5版本。其内部运行原理分为两个步骤：<br>1.利用API实现右键获取准星所指方块的三维坐标，存储在变量中并唤出GUI选择是否保存坐标。坐标存储在数据文件中。<br>2.确定想要复制的单位的两个端点，右键打开GUI设定向上复制的层数，确定后会计算目标坐标，并且执行&#x2F;clone指令进行复制，循环一定次数，到达设定层数后完成复制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;建筑楼层批量复制模组（Bulk copy of building floor），为创造模式制作的建筑辅助模组，确定单层楼层的端点坐标后一次性向上复制多层楼层，可以避免楼层复制指令的重复使用。&lt;br&gt;模组运行原理为按照规律自动生成并执行多条 &amp;#x2F;clone 指令。&lt;/</summary>
      
    
    
    
    <category term="IT技术" scheme="https://djyy24.github.io/djyy24/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://djyy24.github.io/djyy24/tags/Java/"/>
    
    <category term="Minecraft" scheme="https://djyy24.github.io/djyy24/tags/Minecraft/"/>
    
  </entry>
  
  <entry>
    <title>还原90年代老式旅馆楼房</title>
    <link href="https://djyy24.github.io/djyy24/2023/08/02/%E8%BF%98%E5%8E%9F90%E5%B9%B4%E4%BB%A3%E8%80%81%E5%BC%8F%E6%97%85%E9%A6%86%E6%A5%BC%E6%88%BF/"/>
    <id>https://djyy24.github.io/djyy24/2023/08/02/%E8%BF%98%E5%8E%9F90%E5%B9%B4%E4%BB%A3%E8%80%81%E5%BC%8F%E6%97%85%E9%A6%86%E6%A5%BC%E6%88%BF/</id>
    <published>2023-08-02T14:00:05.000Z</published>
    <updated>2023-08-17T07:14:53.980Z</updated>
    
    <content type="html"><![CDATA[<p>Minecraft还原的九十年代风格旅馆大楼，原型为黑龙江九三火车站对面的白色大楼。<br><img src="https://img1.imgtp.com/2023/08/02/lLXbXsMs.png"><br>黑龙江九三火车站（富西铁路线上的车站）一直是童年记忆中最难忘的一座车站，小时候回老家在这里下车，然后乘坐汽车穿过大片农田，到老家的村子。出了九三火车站之后看到的的一座楼房便是双山镇的站前旅馆，当时年少的自己感觉看到这栋大楼就是到老家了，下次再看见的话就是过完年准备坐火车回辽宁了。<br>今年（2023年）夏天时隔七年多再次回到了老家，沿着那些回忆过无数次的小路，一座座在梦境中出现过小楼房映入自己的眼帘，慢慢地找回童年时代的记忆。<br>随着K497次列车缓缓进入九三站，在看到红色九三站的站房之前便看到了站前的四层旅馆楼，仍然是童年记忆中那栋蓝色窗户的大楼，不同的是上一次到这里还是雪地。<br><img src="https://img1.imgtp.com/2023/08/02/4Lwfp78F.png"><br>回到辽宁之后，打算开始还原这栋典型的90年代风格的大楼。</p><p>九十年代楼房设计中一种很常见的风格就是白色条形瓷砖墙面配上蓝色的铝合金窗或者玻璃幕墙，设计上一般比较大气。<br><img src="https://img1.imgtp.com/2023/08/02/FZmuh4Dm.png"><br><img src="https://img1.imgtp.com/2023/08/02/60yJflsX.png"><br>这里面的铝合金窗材质是在原版材质的基础上进行改动而来，白瓷砖材质是之前拍下学校图书馆的墙面之后修图得到的。<br><img src="https://img1.imgtp.com/2023/08/02/YxxSEbCO.png"><br>那个年代的大楼一般会在走廊的一侧安装外部楼梯，用于消防。楼梯有水泥制成的也有铁制楼梯，走廊尽头的消防门通向外侧的消防楼梯。<br><img src="https://img1.imgtp.com/2023/08/02/ebWSrEpP.png"><br>大楼的内饰是自己设计的，因为没进去过旅馆大楼的里面。一楼是店铺，旅馆入口在玻璃幕墙这部分的下面，内部墙面有蓝色的底，旅馆内部装饰有服务台与墙画，二楼有一个大厅，配有落地窗和沙发等。<br><img src="https://img1.imgtp.com/2023/08/02/kVwKxiY9.png"><br><img src="https://img1.imgtp.com/2023/08/02/54N3VCyK.png"><br>大楼位于街角，游戏中设计为一个十字路口，未来会在路口的四个方向都盖上不同风格的拐角楼并且完善附近的配套设施，形成一个小的街区。<br><img src="https://img1.imgtp.com/2023/08/02/ggd73lvN.png"></p><p>（2023.8.3更新）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Minecraft还原的九十年代风格旅馆大楼，原型为黑龙江九三火车站对面的白色大楼。&lt;br&gt;&lt;img src=&quot;https://img1.imgtp.com/2023/08/02/lLXbXsMs.png&quot;&gt;&lt;br&gt;黑龙江九三火车站（富西铁路线上的车站）一直是童年记忆中最难</summary>
      
    
    
    
    <category term="Minecraft" scheme="https://djyy24.github.io/djyy24/categories/Minecraft/"/>
    
    
    <category term="建筑" scheme="https://djyy24.github.io/djyy24/tags/%E5%BB%BA%E7%AD%91/"/>
    
    <category term="Minecraft" scheme="https://djyy24.github.io/djyy24/tags/Minecraft/"/>
    
    <category term="时代记忆" scheme="https://djyy24.github.io/djyy24/tags/%E6%97%B6%E4%BB%A3%E8%AE%B0%E5%BF%86/"/>
    
  </entry>
  
  <entry>
    <title>基于Echarts大数据房价数据分析及可视化</title>
    <link href="https://djyy24.github.io/djyy24/2023/08/02/%E5%9F%BA%E4%BA%8EEcharts%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%BF%E4%BB%B7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://djyy24.github.io/djyy24/2023/08/02/%E5%9F%BA%E4%BA%8EEcharts%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%BF%E4%BB%B7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96/</id>
    <published>2023-08-02T11:29:47.000Z</published>
    <updated>2023-08-02T13:23:18.159Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.1 线性规划模型</strong><br>回归是基于已有数据对新的数据进行预测，比如预测股票走势。这里我们主要讲简单线性回归。基于标准的线性回归，可以扩展出更多的线性回归算法。线性回归就是能够用一个直线较为精确地描述数据之间的关系，这样当出现新的数据的时候，就能够预测出一个简单的值。<br>线性回归模型有很好的可解释性，可以从权重W直接看出每个特征对结果的影响程度。线性回归适用于X和y之间存在线性关系的数据集，可以使用计算机辅助画出散点图来观察是否存在线性关系。我们尝试使用一条直线来拟合数据，使所有点到直线的距离之和最小。</p><p><strong>1.2 项目概述</strong><br>本项目通过爬虫获取链家网深圳二手房信息，包括二手房的区县，地段，介绍，税收，户型，朝向等信息，对这些信息进行预处理之后存入数据框。通过Echarts绘制数据可视化图表，获得对深圳房产信息的直观展示大屏，根据数据可视化大屏，对照深圳市地图以及深圳各个地段背景信息，分析出影响深圳市房价的因素。以及对房产数据构建线性回归模型，并利用tkinter构建图形用户界面，获取用户输入后在程序底层使用线性回归模型进行计算，为用户显示出房产估价，便于用户的使用。</p><p><strong>二.利用网络爬虫获取二手房信息</strong><br><strong>2.1 数据来源及介绍</strong><br>    数据集收集了链家深圳二手房网共计19,547条二手房销售数据，每个数据反映了深圳市一套二手房的地段，单价等基本信息。爬取到的信息存入“深圳市房价.xlsx”中。<br>表格 1 数据集各字段含义<br>列名含义<br>Area房产所在县区<br>Title房产描述<br>Community所在小区<br>Position所在地段<br>Tax纳税情况<br>Total_price总价（万元）<br>Unit_price单价（元&#x2F;平方米）<br>hourseType户型<br>hourseSize面积大小（平方米）<br>direction房屋朝向<br>fitment装修情况</p><p><strong>2.2 网络爬虫概述</strong><br>网络爬虫是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。爬虫对某一站点访问，如果可以访问就下载其中的网页内容，并且通过爬虫解析模块解析得到的网页链接，把这些链接作为之后的抓取目标，并且在整个过程中完全不依赖用户，自动运行。<br>网络爬虫按照一定的规则自动浏览、检索网页信息的程序或者脚本。网络爬虫能够自动请求网页，并将所需要的数据抓取下来。通过对抓取的数据进行处理，从而提取出有价值的信息。</p><p><strong>2.3 requests库概述</strong><br>Python中的requests库为第三方库，是基于Urllib采用Apache2 Licensed开源协议的HTTP库。通过requests.session()函数构建一个会话。使用headers&#x3D;设置请求头，请求头包含了浏览器信息，用于把爬虫伪装成浏览器。使用get(“url”,headers&#x3D;”headers”)获取网页，对应了HTTP协议中的GET请求，使用这个函数可以取得URL对应的HTML文档内容（字符串），用于在其中提取信息。<br>HTTP协议，又称为超文本传输协议，是互联网上应用最为广泛的一种网络协议，所有的WWW文件都必须遵循这个标准。设计HTTP最初的目的是提供一种接收HTML页面的方法，HTTP是一种基于“请求与响应”模式的，无状态的应用层协议。HTTP协议采用URL（统一资源定位符）作为单位网络资源的。在互联网上每个文件都有它专属的URL地址，它包含的信息指出文件的位置，以及浏览器或程序应该如何处理它。</p><p><strong>2.4 利用网络爬虫爬取链家地产网站深圳二手房信息</strong><br>访问链家二手房交易网站（地点选择深圳市）通过观察网页页面结构以及开发者模式下寻找HTML元素与网页结构的对应关系，确定了网页中单价，总价，描述信息，是否有五年房本以及所在区县等信息以及各个信息在HTML中的位置。通过观察HTML文档中这些信息上下文的特点，利用正则表达式对需要提取的信息进行定位，定位之后提取出这些信息，保存到pandas数据框中。<br>本次项目使用Python request库对链家房产网站的二手房出售信息进行爬取。<br>分为以下步骤：<br>1准备程序包。.Python爬虫需要安装req  uests包，因此先使用pip install命令导入导入requests包，设置请求header，并且根据链家二手房网站的基本URL建立带有请求header的会话，以便于后续发送get请求爬取HTML字符串。<br>2.定位页面元素。打开浏览器，进入到链家深圳市福田区的二手房交易网站，打开开发者模式，通过认真观察网页的HTML以及将要提取的数据附近HTML字符串的特征，构造符合将要提取数据的正则表达式，在所爬取的HTML字符串中匹配到所需的总价，位置等信息，以便于后续进行爬虫操作。<br>3.构造请求URL。依次进入链家地产网的深圳市各县区的页面，发现每个页面URL最后一段字符串对应一个区县。建立一个字典，键表示为各个区县，值表示为URL最后一段那段字符串，例如福田区对应futianqu。然后构造循环，依次带入字典中的元素（键和值），根据链家网站深圳各个区县的页面URL构造网站请求URL（即在&#x2F;ershoufang&#x2F;后面加上字典里面存的区县字段）<br>4.获取二手房数量。在上面构造的循环里面加上一个获取页数和二手房总数的请求，获取每个区县的二手房数量以及这个区县的页面总页数。<br>5.数据提取与保存。构造一段循环，爬取每一页中的HTML，爬取使用已构造的URL，通过GET请求爬取各个区县每一页的房产数据，并且按照逐条房地产信息把HTML拆分成若干段，然后再构造一个循环把上述HTML中每一部分，在所爬取的HTML片段中提取房产信息，保存到pandas数据框中，移交给数据清洗部分。<br>本次爬取的数据为房价信息的原始数据，后续过程中需要对所爬取的房地产数据进行分析以及数据可视化，在这其中较为核心的数据为房产的单价和总价信息，后续会利用这些数字信息进行可视化以及数据分析，因此需要把这些数据处理好以便于后续计算。<br> <img src="http://djyy24.github.io/imgs/fjfx_1.png"><br>图 1 采集到的数据</p><p><strong>三.利用pandas库对二手房数据进行清洗</strong><br><strong>3.1数据清洗的概述</strong><br>在大数据分析过程中，计算数据之前需要对数据进行清洗，去掉数据中的无用值。数据清洗是对数据进行重新审查和校验的过程，目的在于删除重复信息、纠正存在的错误，并提供数据一致性。我们获得的（录入计算机后的）原始数据，有时并不能直接用于计算，建模等后续操作，因为可能存在重复或者错误，比如重复录入，小数点错误等，这是需要将这些“脏”的东西洗掉，以保证数据的正确，整洁等。</p><p><strong>3.2 对二手房数据进行预处理</strong><br>在上一步（利用网络爬虫爬取链家地产网站深圳二手房信息）我们利用python中的requests库构建爬虫爬取到了链家深圳各县区的二手房房价，描述信息，位置与户型等数据。但是有一点需要注意到，HTML为超文本标记语言，它包括一系列标签，通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。超文本是一种组织信息的方式，它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。这种组织信息方式将分布在不同位置的信息资源用随机方式进行连接，为人们查找，检索信息提供方便。比较常见的HTML5文档为字符串构成的文档，在网页HTML中直接提取出来的面积，房地产总价和单价信息为字符串类型，字符串类型不是int,float等数字类型，无法直接进行数值计算。通过float()直接把提取出的总价信息与面积信息转换成float类型。但是在所爬取的字符串的“单价”数字中存在逗号分隔，使用str. replace(‘,’, ‘’)去掉逗号，再转换成float类型，存入数据框。</p><p><strong>3.3 使用如下几个步骤对所采集的房地产数据进行清洗</strong><br>1.遍历数据框的每一行，检查数据中除“税收”字段外的所有字段，删掉其中存在“None”的数据。<br>2.遍历数据中的“税收”字段，由于这个字段提取的是网站中房产信息描述中是否有“房本满五年“，没有这个标签则在即不到任何信息，采集不到信息则在此房产信息存入数据框时此字段存入None。由于该字段只有“房本满五年”与“None”两种取值，因此去掉所有这两个值之外的数据。<br>3.检查float型字段（总价，单价，面积），因为房价和面积不可能存在小于零的情况或者等于零的情况，我们不能排除链家网站服务器中的数据是准确的，因而需要把采集到的数据进行清理，去掉所有不合理的数据，这三个字段的取值必须为大于0的数，不可取为0或负数。</p><p><strong>3.4 数据清洗的意义</strong><br>大数据时代，产生的数据多以非结构化数据为主，由于非结构化数据并不能直接为研究所用，因此多数情况下，需要将非结构结构化数据转化成结构化数据，而在这个过程中，就存在必要的数据清洗，将其转化成符合研究的数据格式。</p><p><strong>四.利用Echarts百度开源可视化工具对数据进行可视化</strong><br><strong>4.1 Echarts概述</strong><br>ECharts（Enterprise Charts）是百度开源的数据可视化工具，底层依赖轻量级Canvas库ZRender。兼容了几乎全部常用浏览器的特点，使它可广泛用于PC客户端和手机客户端。ECharts能辅助开发者整合用户数据，创新性的完成个性化设置可视化图表。本项目在Python中导入Pyecharts实现房地产价格数据的可视化，并导出HTML文件，在浏览器中显示图表大屏。<br>制作数据大屏分为以下主要步骤：<br>1.导入Pyecharts第三包，作出准备；<br>2.按照因素对数据集进行分组，存入临时数据框；<br>3.对临时数据集进行计算，求出图表绘制所需的平均值或比例等数据；<br>4.把数据集代入Pyecharts库函数对应的图标生成函数，在函数的参数中调整相应的设置；<br>5.渲染图表，重复上述4步做出其他图表；<br>6.使用Pyecharts当中的组合图表功能，将所有图片拼接在一张html文件中进行展示</p><p><strong>4.2 绘制深圳市二手房的数据图表</strong><br>4.2.1深圳市各区县房价数据地图可视化<br>Pyecharts包提供了通过数据框与样式设置生成地图，柱状图等可视化图形的方法，通过此第三方包可以生成视觉效果较为直观的各类图表，做成数据大屏。<br>使用dataframe.groupby()对处理后的数据按照区县为键进行聚合，求出每个区县的房价均价平均值并且重置索引。初始化Map，把区县和均价的数据（把元转换成万元）以及相关设置（标题，单位，标签显示等）带入到初始化的Map中，然后使用map.render_notebook()把map渲染在Jupyter Notebook里面，用于图表显示测试。<br>4.2.2 深圳市二手房均价TOP 10地段<br>上一步使用的是临时数据框，因而data数据框中保存的仍然是原始数据。使用dataframe.groupby()把data数据框中的数据以地段为键进行分组，求得每组平均值存入临时数据框temp，生成深圳市各区域地段的平均房价，根据所得数据生成柱状图。<br>4.2.3 深圳市二手房 户型数量分布<br>把预处理好的数据的户型列提取出来，存入临时数据框temp。计算临时数据框中所保存的每种户型类型各自所占的比例。把每种户型按照比例排名之后使用Echart.charts中的Pie根据所统计及排名的数据生成饼状图。<br>4.2.4 深圳市房源描述词云图<br>把预处理好的数据的房源描述信息提取出来，存入一个字符串中，使用jieba库对房源描述信息进行分词。把去掉停用词的词语列表中取出其中数量最多的50个词，放入一个集合中，生成词云。使用Echarts中的Page组合图表，布局后生成chart_config.json，然后调用page.save_resize_html生成图表大屏的HTML。<br><img src="http://djyy24.github.io/imgs/fcfx.png"><br>图 2 数据可视化大屏</p><p><strong>五.利用线性回归模型进行房产估价</strong><br><strong>5.1 线性回归模型概述</strong><br>线性回归方程是利用数理统计中的回归分析，来确定两种或两种以上变数间相互依赖的定量关系的一种统计分析方法之一。线性回归也是回归分析中第一种经过严格研究并在实际应用中广泛使用的类型。按自变量个数可分为一元线性回归分析方程和多元线性回归分析方程。<br>在线性回归中，数据使用线性预测函数来建模，并且未知的模型参数也是通过数据来估计。这些模型被叫做线性模型。最常用的线性回归建模是给定X值的y的条件均值是X的仿射函数。不太一般的情况，线性回归模型可以是一个中位数或一些其他的给定X的条件下y的条件分布的分位数作为X的线性函数表示。像所有形式的回归分析一样，线性回归也把焦点放在给定X值的y的条件概率分布，而不是X和y的联合概率分布（多元分析领域）。<br>线性回归优点：善于获取数据集中的线性关系；适用于在已有了一些预先定义好的变量并且需要一个简单的预测模型的情况下使用；训练速度和预测速度较快；在小数据集上表现很好；结果可解释，并且易于说明；当新增数据时，易于更新模型；不需要进行参数调整（下面的正则化线性模型需要调整正则化参数）；不需要特征缩放等优点。<br>线性回归缺点：不适用于非线性数据；预测精确度较低；可能会出现过度拟合（下面的正则化模型可以抵消这个影响）；分离信号和噪声的效果不理想，在使用前需要去掉不相关的特征；不了解数据集中的特征交互；如果数据集具有冗余的特征，那么线性回归可能是不稳定的等缺点。<br>我们使用线性回归方程对所采集到的深圳市二手房信息构建回归模型，以达到用户可以输入自己期望的地段，户型等信息了解该基本信息下大概的房产价格，用户可以根据所估算的价格进行初步决策，以及用户可以输入多组信息相互比较，得出自己的结论。</p><p><strong>5.2 构建前的数据预处理</strong><br>构建线性回归方程之前的数据预处理过程如下：<br>1.去掉总价，面积，区县这三列，总价取决于单价和面积，因为面积无法确定单价，也就是说这一列的取值不会决定单价最终的值，所以把总价这一列去掉。由于面积和单价没有因果关系，面积为总价除以单价所得的值，不会影响单价，所以面积这一列去除掉。本次线性回归分析针对的自变量中含有地段，一个县区包含了多个地段，地段的精确度比计算县区更大，所预测的信息更精准，因此使用地段信息代替区县作为房产区域位置。<br>2.剩余的数据中存在字符串类型，因此应该把字符串转变为数字类型，一便于计算线性回归方程。使用groupby()把数据框中的一个自变量列和单价列提取出来，按照自变量的值（字符串）进行分类，求出每一类的均值，把这个均值赋给这个自变量中对应的字符串，把字符串和数字的对应关系保存到excel文件中。由于tax列只有两种取值，所以这一列取为布尔值即可。处理完成各列数据后，每一列的数据均为数值类型，以便于后续过程中构建线性回归模型。预处理之后的数据存入excel中，命名为“数字化.xlsx”。</p><p><strong>5.3 利用房产数据构建线性回归方程</strong><br>    1.数据集的准备。把上一步预处理之后的数据读取excel后存入一个数据框，作为构建线性回归方程的数据集。<br>2.设置自变量和因变量。从数据框中取出作为自变量的列，把这些列存入X变量中，作为自变量矩阵。从数据框中取出一列（单价）作为因变量，存入变量Y中。<br>3.模型的初始化。使用LinearRegression()初始化线性回归模型，保存到变量LR中，此时LR中还没有训练过的线性回归模型。<br>4.准备训练集和测试集。使用train_test_split()对训练集进行拆分，随机拆分成8：2的两部分，其中80%作为训练集，20%作为测试集。<br>5.训练模型。把已经拆分的自变量和因变量（训练集部分）带入LR对象的fit()方法中，进行模型的构建，取出模型中的五个权重和截距，保存在文本文件weight.txt中，用于后续房价预测程序权重截距的读取。<br>6.平均方误差的计算以及决定系数的计算。使用mean_squared_error()函数，带入因变量的实际值和预测值，计算出模型的平均方误差。然后把拆分出的测试集中的自变量和因变量带入linear_regressor.score(x_test,y_test)函数中求得决定系数为0.71左右，说明模型的预测存在一些的误差。</p><p><strong>5.4 房价估算程序以及利用tkinter包构建图形用户界面</strong><br>5.4.1 房价估算程序<br>构建函数calPrice(args)，参数中包括了地段，户型等基本信息和面积。在这个函数中，首先读取数据预处理过程中保存的数值和字符串的对应关系文档（excel），获得字符串对应的数。然后使用with open()打开线性回归方程构建过程中生成的文本文件，提取其中的值并转换为float类型。构建房价计算方程，函数的形参对应的数值作为这个方程的自变量，实参作为这个方程的自变量系数，后面加上截距，通过带入形参对应的数值可以计算出房价单价信息。单价信息乘上面积获得总价信息。把单价信息和总价信息放入一个元组，这个元组作为函数的返回值。若形参中存在非法字段，则返回由两个’Nan’构成的元组，后续步骤中若返回值为(‘Nan’,’Nan’)则弹出提示信息，不显示房价信息。<br>5.4.2 房价估算程序GUI界面<br>在GUI（图形用户界面）中，用户可以通过其中的图形对象进行操作，设备收到操作指令后，对用户进行结果的反馈，反馈的结果即用户接收到的信息也是图形对象，因此用户无须具备专业知识和操作技能就能够实现操作。作为一种界面显示格式， GUI设计极大地方便了用户的操作。<br>为便于用户使用房价估算程序，我们使用Python中的图形用户界面程序包“tkinter”。首先使用tk.Tk()建立一个root容器，初始化文字提示信息以及各个控件，包括地段输入框，装修信息的下拉菜单，税收的复选框等输入控件及计算按钮和输出框。按照Grid网格把GUI每个元素排列进容器中，设置元素间的距离防止排列过于紧凑。为计算按钮绑定函数，在所绑定的函数中设置输入控件的取值代码，把这些值带入到calPrice函数，把返回值显示在右侧的单价显示框和总价显示框中。<br><img src="http://djyy24.github.io/imgs/fjfx_3"><br>图 3 GUI界面</p><p><strong>六.房产价格数据分析</strong><br><strong>6.1 县区因素对房价供需关系的影响</strong><br>观察深圳各县区的房价分布地图可知，深圳市南山区和福田区是深圳市房价评均单价最高的两个县区，达到了7万元以上的每平方米单价，而远离市中心的坪山区房价较低，仅3.5万元&#x2F;平方米。深圳市各个区域的房价与供需关系存在巨大差异。例如，福田区和南山区是深圳市房价较高的区域，这与它们的区位、教育资源、经济发展水平等因素有关。同时，不同区域的政策支持和市场预期也会影响其房价的供需关系。</p><p><strong>6.2 区域因素对房价供需关系的影响</strong><br>深圳市各个街区的房价与供需关系也存在巨大差异。在地图中寻找这些排名前十的街区我们发现，房价较高的街区多数位于深圳市的金融行业活跃的地区，靠近港口的贸易发达地区，位于深圳和香港交界处的保税区附近或者配套设施齐全，教育资源与经济水平较发达的市中心地区。<br><img src="http://djyy24.github.io/imgs/fjfx_3"><br>图 4 深圳房价Top10地段分布<br>例如，深圳湾以及科技园区域位于深圳口岸，贸易活动频繁，港口经济贸易发达，房价较高。香蜜湖地区位于深圳和香港交界处，附近有福田火车站与保税区等地方，处于地方交通枢纽，商业发达，交通方便，房价仅次于深圳湾。<br>福田区和南山区是深圳市房价较高的区域，这与它们的区位、教育资源、经济发展水平等因素有关。同时，不同区域的政策支持和市场预期也会影响其房价的供需关系。</p><p><strong>6.3 从深圳市房源描述词云图可以看出</strong><br>购房者最多关注的是“唯一”，“诚心”，“五年”等信息，可以看出购房者希望从出售者以及开发商的诚心，购房者希望可以安心的卖到一套符合心意的房产。从“五年“可以看出购房者希望可以买到有五年房本的二手房减少上税，减轻经济上的负担。其它方面例如购房者关心户型与采光，房产的居住体验如何，是否舒适等因素，以及地理位置上是否靠近地铁口，交通上是否方便等因素。</p><p><strong>七.评价与优化</strong><br>本项目是一个基于大数据技术的房价数据分析及可视化项目。通过该项目，我们对大量的房地产数据进行了的分析和可视化呈现，为房地产行业的相关决策提供了有价值的洞察和参考。<br>在项目中，我们采集了大量的房地产数据，包括房价、税收、地理位置、建筑特征等。通过数据清洗和预处理，我们确保了数据的准确性和一致性，并为后续的分析工作做好了准备。<br>通过这个项目，我们为房地产行业提供了一个分析工具，帮助相关人员更好地理解市场动态、制定决策和规划战略。同时，我们还通过可视化呈现，将复杂的数据变得易于理解和消化，为非技术人员提供了一种直观的方式来获取有关房价数据的信息。<br>基于线性回归的房地产估价程序可以比较粗略地估计出指定地段，户型等条件下房产的价格，以供房地产购买者估算房价，进而做出相应的选择。由于自变量数量较少，离散变量处理不够科学等原因，该估价程序较现实价格存在一定的差异，不能很准确地估计出房价信息。<br>总体而言，本项目的成功实施为房价数据的深度分析和可视化展示提供了一个可行的解决方案。在未来，该项目还可以进一步扩展和优化，以适应不断变化的房地产市场需求，为更多的决策者和投资者提供有价值的数据洞察。</p><p>2023.5.30编写</p><p>keywords: “Python,大数据,线性回归,可视化”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;1.1 线性规划模型&lt;/strong&gt;&lt;br&gt;回归是基于已有数据对新的数据进行预测，比如预测股票走势。这里我们主要讲简单线性回归。基于标准的线性回归，可以扩展出更多的线性回归算法。线性回归就是能够用一个直线较为精确地描述数据之间的关系，这样当出现新的数据的时</summary>
      
    
    
    
    <category term="IT技术" scheme="https://djyy24.github.io/djyy24/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="大数据" scheme="https://djyy24.github.io/djyy24/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="Python" scheme="https://djyy24.github.io/djyy24/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>辽宁大学崇山校区WEB互动平面图</title>
    <link href="https://djyy24.github.io/djyy24/2023/08/02/%E8%BE%BD%E5%AE%81%E5%A4%A7%E5%AD%A6%E5%B4%87%E5%B1%B1%E6%A0%A1%E5%8C%BAWEB%E4%BA%92%E5%8A%A8%E5%B9%B3%E9%9D%A2%E5%9B%BE/"/>
    <id>https://djyy24.github.io/djyy24/2023/08/02/%E8%BE%BD%E5%AE%81%E5%A4%A7%E5%AD%A6%E5%B4%87%E5%B1%B1%E6%A0%A1%E5%8C%BAWEB%E4%BA%92%E5%8A%A8%E5%B9%B3%E9%9D%A2%E5%9B%BE/</id>
    <published>2023-08-02T06:27:48.000Z</published>
    <updated>2023-08-03T13:29:44.445Z</updated>
    
    <content type="html"><![CDATA[<p>此平面地图为信息学院20级学生自制的HTML5互动地图，在基于卫星地图绘制的几何图形平面地图的基础上增加了图文信息窗口，地点搜索等互动功能。<br><a href="http://8.141.83.100:91">辽宁大学崇山校区WEB互动平面图</a><br><a href="http://8.141.83.100:91">辽宁大学崇山校区WEB互动平面图（阿里云）</a><br>       制作互动地图的想法早在一年前就有了，2022年6月曾计划制作基于JavaFX的辽大互动地图，但因为Java软件对运行环境有一定要求，可能不易于使用，从而难以推广，最终没有落实。今年学习了WEB开发，于是借助HTML5灵活易用的特点以及JavaScript对运行环境的低要求，制作了这个更易于使用的HTML5互动地图。<br>       六月份先后两次，趁着天气晴朗拍摄了共计183张崇山校区各个建筑外景照片，用于地点图文信息的编写。所有代码，文案及美工等工作都由一人完成，从5月26日开始，耗时19天完成1.0版本，实现了地点图文信息查看以及模糊搜索功能。<br>       由于一个人经历有限，掌握的信息不算多，因此地图提供的信息不够完善，后续将在更新时补充更多更准确的信息。<br>       此平面图为基于HTML5的网页版平面图，通过浏览器即可使用，并带有互动功能，提供更加丰富的信息。<br>       <img src="https://djyy24.github.io/imgs/lnumap.png"><br><br>在地点搜索框中输入建筑名称或者院系，店铺等名称后，点击“搜索”按钮后在地图上会突出显示所查找的地点。<br>       <img src="https://djyy24.github.io/imgs/lnumap_search.png"><br></p><p>点击地图中的建筑图块弹出图文信息窗口，点击图片切换按钮可以查看更多图片。<br>      <img src="https://djyy24.github.io/imgs/lnumap_loc.png"><br>      IFrame:<br>       <iframe src="http://8.141.83.100:91" scrolling="yes" border="0" width="785px" height="430px" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此平面地图为信息学院20级学生自制的HTML5互动地图，在基于卫星地图绘制的几何图形平面地图的基础上增加了图文信息窗口，地点搜索等互动功能。&lt;br&gt;&lt;a href=&quot;http://8.141.83.100:91&quot;&gt;辽宁大学崇山校区WEB互动平面图&lt;/a&gt;&lt;br&gt;&lt;a hre</summary>
      
    
    
    
    <category term="IT技术" scheme="https://djyy24.github.io/djyy24/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="https://djyy24.github.io/djyy24/tags/JavaScript/"/>
    
    <category term="HTML" scheme="https://djyy24.github.io/djyy24/tags/HTML/"/>
    
  </entry>
  
</feed>
